import { Graphviz } from "@hpcc-js/wasm/graphviz";
import { dedent } from "@qnighy/dedent";
import { JSDOM } from "jsdom";
import rehypeStringify from "rehype-stringify";
import remarkParse from "remark-parse";
import remarkRehype from "remark-rehype";
import { unified } from "unified";
import { beforeAll, describe, expect, test } from "vitest";
import { defaultRehypeGraphvizOption, rehypeGraphviz } from "./plugin";

/**
 * Convert markdown to HTML.
 */
const md2html = async (mdText: string) => {
	const html = await unified()
		.use(remarkParse)
		.use(remarkRehype)
		.use(rehypeGraphviz, {
			graphviz: await Graphviz.load(),
		})
		.use(rehypeStringify)
		.process(mdText);
	return html.toString();
};

/**
 * Remove indentations and line breaks.
 */
const format = (text: string) =>
	text
		.replaceAll(/^(?<indent>\s*)(?<content>.*)$/gm, "$<content>")
		.replaceAll("\n", "");

describe("utils: format", () => {
	test("should remove indentations and line breaks", () => {
		const text = `
      <div>
        <p>foo</p>
        <p>bar</p>
      </div>
    `;
		const expected = "<div><p>foo</p><p>bar</p></div>";
		expect(format(text)).toBe(expected);
	});
});

describe("rehypeShiki", () => {
	let jsdom: JSDOM;
	let parser: DOMParser;

	beforeAll(() => {
		jsdom = new JSDOM();
		parser = new jsdom.window.DOMParser();
	});

	test("should render graphviz diagram", async () => {
		const md = (lang: string) => dedent`
      \`\`\`${lang}
      digraph G {
        splines="FALSE";

        /* Entities */
        shortName [label="shortName", shape="square"]

        /* Relationships */
        F1 -> shortName[label=".63"]

        /* Ranks */
        { rank=same; shortName; };
      }
      \`\`\`
    `;

		for (const lang of ["graphviz", "dot"]) {
			const html = format(await md2html(md(lang)));

			const className = defaultRehypeGraphvizOption.className;
			const style = defaultRehypeGraphvizOption.style;
			const expectedHtml = format(`
      <div class="${className}" style="${style}">
        <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->
        <!-- Generated by graphviz version 9.0.0 (0)-->
        <!-- Title: G Pages: 1 -->
        <svg width="85pt" height="174pt" viewBox="0.00 0.00 85.43 174.23" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 170.23)">
            <title>G</title>
            <polygon fill="white" stroke="none" points="-4,4 -4,-170.23 81.43,-170.23 81.43,4 -4,4"></polygon>
            <!-- shortName -->
            <g id="node1" class="node">
              <title>shortName</title>
              <polygon fill="none" stroke="black" points="77.43,-77.43 0,-77.43 0,0 77.43,0 77.43,-77.43"></polygon><text text-anchor="middle" x="38.71" y="-34.51" font-family="Times,serif" font-size="14.00">shortName</text>
            </g>
            <!-- F1 -->
            <g id="node2" class="node">
              <title>F1</title>
              <ellipse fill="none" stroke="black" cx="38.71" cy="-148.23" rx="27" ry="18"></ellipse><text text-anchor="middle" x="38.71" y="-144.03" font-family="Times,serif" font-size="14.00">F1</text>
            </g>
            <!-- F1&#45;&gt;shortName -->
            <g id="edge1" class="edge">
              <title>F1->shortName</title>
              <path fill="none" stroke="black" d="M38.71,-129.95C38.71,-118.9 38.71,-103.95 38.71,-89.4"></path>
              <polygon fill="black" stroke="black" points="42.21,-89.41 38.71,-79.41 35.21,-89.41 42.21,-89.41"></polygon>
              <text text-anchor="middle" x="47.46" y="-99.63" font-family="Times,serif" font-size="14.00">.63</text>
            </g>
          </g>
        </svg>
      </div>
    `);

			expect(html).toBe(expectedHtml);
		}
	});

	test("should not render graphviz diagram if the language is not dot", async () => {
		const md = dedent`
      \`\`\`python
      print("Hello, world!")
      \`\`\`
    `;

		const html = await md2html(md);
		const doc = parser.parseFromString(html, "text/html");

		expect(doc.querySelectorAll("pre > code").length).toBe(1);
		expect(doc.querySelector("pre > code")?.textContent).toBe(
			'print("Hello, world!")\n',
		);
		expect(doc.querySelector("svg")).toBeNull();
	});

	test("should not render graphviz diagram if the language is not given", async () => {
		const md = dedent`
      \`\`\`
      console.log("Hello, world!")
      \`\`\`
    `;

		const html = await md2html(md);
		const doc = parser.parseFromString(html, "text/html");

		expect(doc.querySelectorAll("pre > code").length).toBe(1);
		expect(doc.querySelector("pre > code")?.textContent).toBe(
			'console.log("Hello, world!")\n',
		);
		expect(doc.querySelector("svg")).toBeNull();
	});

	test("check if `langAssociations` config works", async () => {
		const md = (lang: string) => dedent`
      \`\`\`${lang}
      digraph G {
        splines="FALSE";

        /* Entities */
        shortName [label="shortName", shape="square"]

        /* Relationships */
        F1 -> shortName[label=".63"]

        /* Ranks */
        { rank=same; shortName; };
      }
      \`\`\`
    `;

		type LangTestCases = {
			shouldRender: string[];
			shouldNotRender: string[];
		};
		const langTestCases: LangTestCases = {
			shouldRender: [
				"dot",
				"graphviz-dot",
				"dot-diagram",
				"graphviz-dot-diagram",
			],
			shouldNotRender: [
				"graphviz",
				"dott",
				"dot-graphviz",
				"javascript",
				"json",
			],
		};

		for (const [type, langs] of Object.entries(langTestCases)) {
			for (const lang of langs) {
				const html = unified()
					.use(remarkParse)
					.use(remarkRehype)
					.use(rehypeGraphviz, {
						graphviz: await Graphviz.load(),
						langAssociations: {
							dot: ["graphviz-dot", "dot-diagram", "graphviz-dot-diagram"],
						},
					})
					.use(rehypeStringify)
					.processSync(md(lang))
					.toString();
				const doc = parser.parseFromString(html, "text/html");

				if ((type as keyof LangTestCases) === "shouldRender") {
					expect(
						doc.querySelectorAll("pre > code").length,
						`Code block with \`${lang}\` language should render diagrams.`,
					).toBe(0);
				} else {
					expect(
						doc.querySelectorAll("pre > code").length,
						`Code block with \`${lang}\` language should not render diagrams.`,
					).toBe(1);
				}
			}
		}
	});

	test("check if `className` config works", async () => {
		const md = dedent`
      \`\`\`dot
      digraph G {
        splines="FALSE";

        /* Entities */
        shortName [label="shortName", shape="square"]

        /* Relationships */
        F1 -> shortName[label=".63"]

        /* Ranks */
        { rank=same; shortName; };
      }
      \`\`\`
    `;
		const classNames = ["graphviz-diagram", "graphviz", "diagram"];
		for (const className of classNames) {
			const html = unified()
				.use(remarkParse)
				.use(remarkRehype)
				.use(rehypeGraphviz, {
					graphviz: await Graphviz.load(),
					className,
				})
				.use(rehypeStringify)
				.processSync(md)
				.toString();
			const doc = parser.parseFromString(html, "text/html");

			const digramContainer = doc.querySelector("div");
			expect(
				digramContainer?.className,
				`Container element should have \`${className}\` as its class name.\n`,
			).toBe(className);
		}
	});

	test("check if `style` config works", async () => {
		const md = dedent`
      \`\`\`dot
      digraph G {
        splines="FALSE";

        /* Entities */
        shortName [label="shortName", shape="square"]

        /* Relationships */
        F1 -> shortName[label=".63"]

        /* Ranks */
        { rank=same; shortName; };
      }
      \`\`\`
    `;
		const styles = [
			"overflow: auto;",
			"overflow: clip; background-color: red;",
		];
		for (const style of styles) {
			const html = unified()
				.use(remarkParse)
				.use(remarkRehype)
				.use(rehypeGraphviz, {
					graphviz: await Graphviz.load(),
					style,
				})
				.use(rehypeStringify)
				.processSync(md)
				.toString();
			const doc = parser.parseFromString(html, "text/html");

			const digramContainer = doc.querySelector("div");
			expect(
				digramContainer?.style.cssText,
				`Container element should have \`${style}\` as its class name.\n`,
			).toBe(style);
		}
	});
});
